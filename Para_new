%% doa_parafac_music_from_mat.m
% Load general array geometry from .mat (elt, chan) and run MUSIC vs PARAFAC.
% elt: n x 5  -> [x y z weight spare]  (also accepts 5 x n and will transpose)
% chan: 1 x n -> integer subarray/channel id in 1..m
%
% Optional: collapse to m "channels" by summing (or averaging) elements per subarray
%           and run the whole pipeline in channel-space.

clear; clc; close all;

%% ===================== USER SETTINGS =====================
array_matfile = "my_array.mat";   % <-- your .mat with 'elt' and 'chan'
fc   = 3.5e9;  c = 3e8;  lambda = c/fc;

use_subarray_channels   = false;   % true: operate in m-channel space instead of per-element space
channel_combine_mode    = "sum";   % "sum" or "avg" when collapsing by subarray

% Sources & sim
K        = 3;                       % number of sources
az_deg   = [-20,  15,  60];         % true azimuths (deg)
el_deg   = [ 10,   0, -10];         % true elevations (deg)
SNR_dB   = [10, 5, 0];              % per-source per-sensor SNR (noise var = 1)
source_type = 'qpsk'; fs = 50e3; tone_offsets_Hz = [2e3,4e3,7e3];
Nsnap    = 8000;

% Covariance slicing for PARAFAC
blockLen = 256; overlap = 0.5; powerdiv_sigma = 0.6;
mask_diagonal = true; subtract_noise_floor = true;

% MUSIC scan grids (2D)
AZ_coarse = -90:1.0:90; EL_coarse = -30:1.0:30;
AZ_fine   = -1.5:0.1:1.5; EL_fine  = -1.0:0.1:1.0;

% PARAFAC options
cp_maxit = 300; cp_tol = 1e-6; cp_verbose = true; gamma_damp = 0.9;
ridge_A = 1e-3; ridge_B = 1e-3; ridge_C = 2e-3;

rng(7);
%% ==========================================================

%% ======== Load geometry from .mat and normalize shape =========
S = load(array_matfile, 'elt', 'chan');
if ~isfield(S,'elt')
    error('The .mat must contain variable "elt" (n x 5: [x y z weight spare]).');
end
elt = S.elt;
if size(elt,2) ~= 5 && size(elt,1) == 5
    elt = elt.';  % accept 5 x n and transpose to n x 5
end
if size(elt,2) ~= 5
    error('elt must be n x 5 (or 5 x n).');
end
rxyz = elt(:,1:3);  % positions [x y z] in meters
w    = elt(:,4);    % element amplitude weights (taper)
n    = size(rxyz,1);

if isfield(S,'chan')
    chan = S.chan(:).';  % 1 x n
    if numel(chan) ~= n
        error('chan must be 1 x n (n = %d).', n);
    end
else
    % If chan missing, default every element to subarray 1
    chan = ones(1,n);
end

% Build element->channel collapse matrix if requested
if use_subarray_channels
    chan_ids = unique(chan, 'stable');
    m = numel(chan_ids);
    T = zeros(m, n);           % m x n
    for i = 1:m
        idx = find(chan == chan_ids(i));
        if strcmpi(channel_combine_mode, "avg")
            T(i, idx) = 1/numel(idx);
        else
            T(i, idx) = 1;
        end
    end
    % Effective geometry in channel-space:
    % Steering becomes A_ch = T * (W .* a), where W=diag(w).
    % We will implement steering through a function that returns either element-space
    % or channel-space vectors depending on this flag.
else
    m = n; T = []; %#ok<NASGU>
end

k0 = 2*pi/lambda;

% Steering function returning a column vector in the currently selected space
steer_elem = @(az,el) w .* exp(1j * k0 * ( rxyz * [cosd(el)*cosd(az); cosd(el)*sind(az); sind(el)] ));
if use_subarray_channels
    steer = @(az,el) ( build_channel_vector(steer_elem(az,el), chan, channel_combine_mode) );
else
    steer = @(az,el) steer_elem(az,el);
end

%% ======== Build true steering matrix Atrue (K sources) =========
Atrue = zeros(m, K);
for k = 1:K
    Atrue(:,k) = steer(az_deg(k), el_deg(k));
end

%% ======== Simulate source signals & snapshots in chosen space ===========
switch lower(source_type)
  case 'qpsk'
    Ssig = (sign(randn(K,Nsnap))+1j*sign(randn(K,Nsnap)))/sqrt(2); % unit power
  case 'tone'
    t=(0:Nsnap-1)/fs; Ssig=zeros(K,Nsnap);
    for k = 1:K, Ssig(k,:)=exp(1j*2*pi*tone_offsets_Hz(k)*t); end
  otherwise
    error('Unknown source_type');
end
Ssig = diag( sqrt(10.^(SNR_dB(:).'/10)) ) * Ssig;

X_all = Atrue*Ssig + (randn(m,Nsnap)+1j*randn(m,Nsnap))/sqrt(2); % noise var = 1

%% ======== Overlapped covariance slices with power diversity =============
hop = max(1, round(blockLen*(1-overlap)));
starts = 1:hop:(Nsnap-blockLen+1);
B = numel(starts);

G = exp(powerdiv_sigma*randn(K,B));  % >0 scalers per (k,b)
G = G ./ mean(G,2);

R = zeros(m,m,B);
w_taper = hann(blockLen).'; wn = w_taper/sqrt(mean(w_taper.^2));
for b=1:B
    idx = starts(b)+(0:blockLen-1);
    S_block = Ssig(:,idx) .* sqrt(G(:,b));
    Xb = Atrue*S_block + (randn(m,blockLen)+1j*randn(m,blockLen))/sqrt(2);
    Xb = Xb .* wn;
    R(:,:,b) = (Xb*Xb')/blockLen;
end

% Preprocess slices
Rproc = R;
if subtract_noise_floor
  for b=1:B
    ev = sort(real(eig((R(:,:,b)+R(:,:,b)')/2)),'ascend');
    sig2 = median(ev( max(1,m-3):m ));
    Rproc(:,:,b) = R(:,:,b) - sig2*eye(m);
  end
end
if mask_diagonal
  for b=1:B, Rproc(1:m+1:end,b) = 0; end
end

%% ================= MUSIC (reference) ===================================
Rfull = (X_all*X_all')/Nsnap;
[Ev,D]=eig((Rfull+Rfull')/2);
[~,ix]=sort(real(diag(D)),'descend'); Ev=Ev(:,ix); En=Ev(:,K+1:end);

% Dictionary builder (normalized) in the chosen space
dict = @(az,el) unit_norm( steer(az,el) );

% MUSIC coarse map
[AZm,ELm] = meshgrid(AZ_coarse, EL_coarse);
Na=numel(AZ_coarse); Ne=numel(EL_coarse);
Pcoarse = zeros(Ne,Na);
for ii=1:Ne, for jj=1:Na
    a = dict(AZm(ii,jj), ELm(ii,jj));
    Pcoarse(ii,jj) = 1 / max( norm(En' * a)^2, 1e-12 );
end, end
est_music = pick_topk_2d(Pcoarse, AZ_coarse, EL_coarse, K);

% fine refinement
for k=1:numel(est_music.az)
    azc=est_music.az(k); elc=est_music.el(k);
    az_loc = azc + AZ_fine; el_loc = elc + EL_fine;
    Pf = zeros(numel(el_loc), numel(az_loc));
    for ii=1:numel(el_loc), for jj=1:numel(az_loc)
        Pf(ii,jj) = 1 / max( norm(En' * dict(az_loc(jj), el_loc(ii)))^2, 1e-12 );
    end, end
    pk = pick_topk_2d(Pf, az_loc, el_loc, 1);
    est_music.az(k)=pk.az(1); est_music.el(k)=pk.el(1);
end

%% ================= PARAFAC (CP-ALS) ====================================
Xten = Rproc;  % m x m x B

% Seed A via SVD of average slice + dictionary correlation
Ravg = mean(Rproc,3);
[U0,~,~]=svd((Ravg+Ravg')/2,'econ');
AZi=-90:2:90; ELi=-30:2:30;
Agrid = zeros(m, numel(AZi)*numel(ELi)); idx=1;
for ee=1:numel(ELi), for aa=1:numel(AZi)
    Agrid(:,idx) = dict(AZi(aa), ELi(ee)); idx=idx+1;
end, end
scores = abs(Agrid'*(U0(:,1:K))); [~,imax] = maxk(sum(scores,2), K);
A = phase_anchor(Agrid(:,imax));  Bf = conj(A);  C = max(real(randn(B,K)),0);

fit_prev=0;
for it=1:cp_maxit
    % A update (ridge)
    Z = khatri_rao(C, Bf);
    X1 = reshape(Xten, m, []);
    A_ls = ridge_ls(X1, Z, ridge_A);
    A = (1-gamma_damp)*A + gamma_damp*A_ls;
    A = phase_anchor(A);

    % B update (tie to conj(A))
    Z = khatri_rao(C, A);
    X2 = reshape(permute(Xten,[2 1 3]), m, []);
    B_ls = ridge_ls(X2, Z, ridge_B);
    for kcol=1:K
        ph = angle(sum(conj(B_ls(:,kcol)).*A(:,kcol)));
        B_ls(:,kcol) = exp(1j*ph)*B_ls(:,kcol);
    end
    Bf = conj(A);

    % C update (ridge + NN)
    Z = khatri_rao(Bf, A);
    X3 = reshape(permute(Xten,[3 1 2]), B, []);
    C_ls = ridge_ls(X3, Z, ridge_C);
    C = (1-gamma_damp)*C + gamma_damp*C_ls;
    C = max(real(C), 0);

    % Normalize & masked fit
    [A,Bf,C] = normalize_columns_abc(A,Bf,C);
    num=0; den=0;
    for b=1:B
        Xhat = A*diag(C(b,:))*Bf';
        if mask_diagonal
            Xb = Xten(:,:,b); Xb(1:m+1:end)=0; Xhat(1:m+1:end)=0;
        else
            Xb = Xten(:,:,b);
        end
        num = num + norm(Xb - Xhat,'fro')^2;
        den = den + norm(Xb,'fro')^2;
    end
    fit = 1 - num/max(den,eps);
    if cp_verbose && (mod(it,10)==0 || it==1), fprintf('CP iter %3d, fit=%.6f\n', it, fit); end
    if abs(fit-fit_prev) < cp_tol, break; end
    fit_prev = fit;
end
fprintf('rank(C) ~ %d, cond(C) ~ %.1f\n', rank(C), cond(C));

%% ======== 2D grid matching for PARAFAC columns =========================
est_par = struct('az',[],'el',[]);
for k=1:K
    ak = unit_norm(A(:,k));
    % coarse search
    best = [-Inf, NaN, NaN];
    for ee=1:numel(EL_coarse), for aa=1:numel(AZ_coarse)
        val = abs( ak' * dict(AZ_coarse(aa), EL_coarse(ee)) );
        if val>best(1), best=[val, AZ_coarse(aa), EL_coarse(ee)]; end
    end, end
    % fine
    az_loc = best(2) + AZ_fine; el_loc = best(3) + EL_fine;
    best2 = best;
    for ee=1:numel(el_loc), for aa=1:numel(az_loc)
        val = abs( ak' * dict(az_loc(aa), el_loc(ee)) );
        if val>best2(1), best2=[val, az_loc(aa), el_loc(ee)]; end
    end, end
    est_par.az(k)=best2(2); est_par.el(k)=best2(3);
end

%% ================= Results =============================
true_sorted    = sortrows([az_deg(:), el_deg(:)],[1 2]);
music_sorted   = sortrows([est_music.az(:), est_music.el(:)],[1 2]);
parafac_sorted = sortrows([[est_par.az].', [est_par.el].'],[1 2]);

fprintf('\n=== RESULTS (Az, El in deg) ===\n');
fprintf('True:      %s\n', mat2str(true_sorted));
fprintf('MUSIC:     %s\n', mat2str(music_sorted));
fprintf('PARAFAC:   %s\n', mat2str(parafac_sorted));

%% ================= Helper functions =====================
function v = unit_norm(v), v = v / max(norm(v),eps); end
function A = phase_anchor(A)
  for k=1:size(A,2), ph = angle(A(1,k)); A(:,k) = A(:,k)*exp(-1j*ph); end
end
function Z = khatri_rao(A,B)
  [IA,K]=size(A); [IB,KB]=size(B); if KB~=K, error('KR col mismatch'); end
  Z=zeros(IA*IB,K); for k=1:K, Z(:,k)=kron(A(:,k),B(:,k)); end
end
function [A,B,C]=normalize_columns_abc(A,B,C)
  K=size(A,2);
  for k=1:K
    na=norm(A(:,k)); nb=norm(B(:,k)); if na==0, na=1; end; if nb==0, nb=1; end
    s=sqrt(na*nb); A(:,k)=A(:,k)/s; B(:,k)=B(:,k)/s; C(:,k)=C(:,k)*(s^2);
  end
end
function Xridge = ridge_ls(Y, Z, eps_scale)
  G = Z' * Z; mu = eps_scale * trace(G)/size(G,1);
  Xridge = (Y * Z) / (G + mu*eye(size(G)));
end
function est = pick_topk_2d(map, az_grid_deg, el_grid_deg, K)
  map2=map; est.az=zeros(1,K); est.el=zeros(1,K);
  nbh_az=max(1,round(2/mean(diff(az_grid_deg))));
  nbh_el=max(1,round(2/mean(diff(el_grid_deg))));
  for k=1:K
    [val,idx]=max(map2(:)); if ~isfinite(val)||val<=0, est.az=est.az(1:k-1); est.el=est.el(1:k-1); break; end
    [ii,jj]=ind2sub(size(map2),idx);
    est.az(k)=az_grid_deg(jj); est.el(k)=el_grid_deg(ii);
    i1=max(1,ii-nbh_el); i2=min(size(map2,1),ii+nbh_el);
    j1=max(1,jj-nbh_az); j2=min(size(map2,2),jj+nbh_az);
    map2(i1:i2,j1:j2)=-Inf;
  end
end
function y = build_channel_vector(x_elem, chan, mode)
  % Map element-space vector (n x 1) to channel-space (m x 1) by subarray id in 'chan'
  chan_ids = unique(chan, 'stable'); m = numel(chan_ids);
  y = zeros(m,1);
  for i = 1:m
      idx = (chan == chan_ids(i));
      if strcmpi(mode,"avg")
          y(i) = mean(x_elem(idx));
      else
          y(i) = sum(x_elem(idx));
      end
  end
end
